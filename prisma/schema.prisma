// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_PRISMA_URL")
}

model Album {
  id                        String    @id @default(uuid())
  musicBrainzReleaseGroupId String    @unique
  title                     String
  artist                    String
  year                      Int?
  coverUrl                  String?
  votesCount                Int       @default(0)
  featuredAt                DateTime? // When this album became the featured discussion (null = never featured)
  createdAt                 DateTime  @default(now())
  updatedAt                 DateTime  @updatedAt
  
  votes                     Vote[]
  comments                  Comment[]
  
  @@index([votesCount])
  @@index([musicBrainzReleaseGroupId])
  @@index([featuredAt])
}

model Vote {
  id        String   @id @default(uuid())
  albumId   String
  voterHash String   // Hash of cookie ID + IP address
  createdAt DateTime @default(now())
  
  album     Album    @relation(fields: [albumId], references: [id], onDelete: Cascade)
  
  @@unique([albumId, voterHash])
  @@index([albumId])
  @@index([voterHash])
}

// User for commenting system (email-based auth)
model User {
  id              String        @id @default(uuid())
  email           String        @unique
  displayName     String?       // Optional display name
  createdAt       DateTime      @default(now())
  lastLoginAt     DateTime      @default(now())
  
  comments        Comment[]
  commentLikes    CommentLike[]
  
  @@index([email])
}

// Verification codes for passwordless email auth
model VerificationCode {
  id        String   @id @default(uuid())
  email     String
  code      String   // 6-digit code
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  
  @@index([email, code])
  @@index([expiresAt])
}

// Comments on albums (supports threading via parentId)
model Comment {
  id        String   @id @default(uuid())
  content   String   // The comment text
  albumId   String
  userId    String
  parentId  String?  // If replying to another comment
  likesCount Int     @default(0) // Denormalized count for sorting
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  album     Album    @relation(fields: [albumId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent    Comment? @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[] @relation("CommentReplies")
  likes     CommentLike[]
  
  @@index([albumId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
  @@index([likesCount])
}

// Likes on comments
model CommentLike {
  id        String   @id @default(uuid())
  commentId String
  userId    String
  createdAt DateTime @default(now())
  
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([commentId, userId]) // One like per user per comment
  @@index([commentId])
  @@index([userId])
}
